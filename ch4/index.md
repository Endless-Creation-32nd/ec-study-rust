# Understanding Ownership

소유권(Ownership)은 러스트의 가장 유니크한 특성이며, 러스트가 가비지 콜렉터 없이 메모리 안정성 보장을 하게 해줍니다. 그러므로, 소유권이 러스트 내에서 어떻게 동작하는지 이해하는 것은 중요합니다.

## 소유권이 무엇일까

메모리를 관리하자

GC를 쓰는 언어도 있다. 직접 해제해야 하는 언어도 있다. 러스트에선 소유권으로 관리한다.

### 소유권 규칙

1. 러스트의 각각의 값은 해당값의 오너(owner)라고 불리우는 변수를 갖고 있다.
2. 한번에 딱 하나의 오너만 존재할 수 있다.
3. 오너가 스코프 밖으로 벗어나는 때, 값은 버려진다(dropped).

### 변수의 스코프

변수는 스코프 안에서 유효하다.

### String 타입

스트링 리터럴이 이미 있지만 이것은 immutable이다.

```rust
fn main() {
let mut s = String::from("hello");

s.push_str(", world!"); // push_str()은 해당 스트링 리터럴을 스트링에 붙여줍니다.

println!("{}", s); // 이 부분이 `hello, world!`를 출력할 겁니다.
}
```

String은 mutable할 수 있는데 리터럴 문자열은 왜 변할 수 없을까요?

바로 메모리를 쓰는 방식에 있습니다.

### 메모리와 할당

스트링 리터럴은 내용을 컴파일 타임에 알 수 있으므로 텍스트가 최종 실행파일에 직접 하드코딩 되어있다.
String 타입은 변경 가능하고 커질 수 있는 텍스트를 지원하기 위해 만들어졌다. 따라서 힙에 메모리를 할당받아 저장할 필요가 있고 런타임에 운영체제로부터 메모리가 요청되어야 한다. 그리고 String의 사용이 끝났을 때 운영체제에게 메모리를 반남할 방법이 필요하다.

러스트는 변수가 스코프 밖으로 벗어나면 자동으로 drop을 호출하여 메모리를 반환한다. 항상

### 변수와 데이터가 상호작용하는 방법: 이동(move)

```rust
fn main() {
let s1 = String::from("hello");
let s2 = s1;
}
```

흔히 얕은복사, 깊은복사와 비슷한 개념

![](https://doc.rust-lang.org/book/img/trpl04-02.svg)

s1, s2모두 스코프 밖으로 벗어나게 되면 둘다 같은 메모리를 해제하려 하기 때문에 double free라고 알려진 오류가 발생할 수 있다. 이는 memory curruption의 원인이 된다.

러스트는 s1이 더이상 유효하지 않다고 간주하면서 이 문제를 해결한다. 하지만

```rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1); //에러 발생
```

이러한 러스트의 동작 방식 때문에 러스트는 `얕은 복사`라는 말 대신에 `이동`이라고 부른다.

### 변수와 데이터가 상호작용하는 방법: 클론

깊은 복사

```rust
fn main() {
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
}
```

### 스택에만 있는 데이터: 복사

스택에 있는 데이터는 그냥 복사됨

```rust
fn main() {
  let x = 5;
  let y = x;

  println!("x = {}, y = {}", x, y);
}
```

러스트는 정수형과 같이 스택에 저장할 수 있는 타입에 대해 달수 있는 Copy 트레잇이라고 불리우는 특별한 어노테이션(annotation)을 가지고 있습니다 (트레잇에 관해서는 10장에서 더 자세히 보겠습니다). 만일 어떤 타입이 Copy 트레잇을 갖고 있다면, 대입 과정 후에도 예전 변수를 계속 사용할 수 있습니다. 러스트는 만일 그 타입 혹은 그 타입이 가지고 있는 부분 중에서 Drop 트레잇을 구현한 것이 있다면 Copy 트레잇을 어노테이션 할 수 없게끔 합니다. 만일 어떤 타입이 스코프 밖으로 벗어났을 때 어떤 특수한 동작을 필요로 하고 우리가 그 타입에 대해 Copy 어노테이션을 추가한다면, 컴파일 타임 오류를 보게 됩니다. Copy 어노테이션을 여러분의 타입에 어떤 식으로 추가하는지 알고 싶다면, 부록 C의 파생 가능한 트레잇(Derivable Traits)을 보세요.

그래서 어떤 타입이 Copy가 될까요? 여러분은 주어진 타입에 대해 확신을 하기 위해 문서를 확인할 수도 있겠지만, 일반적인 규칙으로서 단순한 스칼라 값들의 묶음은 Copy가 가능하고, 할당이 필요하거나 어떤 자원의 형태인 경우 Copy를 사용할 수 없습니다. Copy가 가능한 몇가지 타입을 나열해 보겠습니다:

- u32와 같은 모든 정수형 타입들
- true와 false값을 갖는 부울린 타입 bool
- f64와 같은 모든 부동 소수점 타입들
- Copy가 가능한 타입만으로 구성된 튜플들. (i32, i32)는 Copy가 되지만, (i32, String)은 안됩니다.

### 소유권과 함수
